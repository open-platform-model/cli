## ADDED Requirements

### Requirement: Values validation uses recursive field walking with custom closedness checking

The ReleaseBuilder's values-against-config validation (Step 4b) SHALL validate user-provided values against the `#config` definition by recursively walking every field in the merged values struct and checking each field against the corresponding schema node.

At each level of recursion, the validator SHALL:

1. Check if the field is allowed by the schema using `cue.Value.Allows()`. If not allowed, the validator SHALL emit a "field not allowed" error and SHALL NOT recurse into the field's children.
2. Resolve the schema field — first via literal field lookup (`LookupPath(MakePath(sel))`), then via pattern constraint resolution (`LookupPath(MakePath(Str(key).Optional()))`) for fields matched by `[Name=string]: { ... }` patterns.
3. Unify the data field with the resolved schema field and check for type/constraint errors. If errors exist, the validator SHALL NOT recurse into the field's children.
4. If the field is a struct and passes validation, recurse into its children with the resolved schema field as the new schema context.

The validator SHALL handle arbitrary nesting depth.

#### Scenario: Top-level disallowed field is caught

- **WHEN** values contain a field `"extra-field"` that does not exist in `#config`
- **AND** `#config` is a closed definition with no pattern constraint at the top level
- **THEN** the validator SHALL emit a "field not allowed" error for `values."extra-field"`
- **AND** the error SHALL include the file:line:col position from the values file where the field is defined

#### Scenario: Nested disallowed field inside allowed struct is caught

- **WHEN** values contain `media: { tvshows: { badField: "oops" } }`
- **AND** `#config.media` uses a pattern constraint `[Name=string]: { mountPath: string, size: string }`
- **AND** the pattern's inner struct does not allow `badField`
- **THEN** the validator SHALL emit a "field not allowed" error for `values.media.tvshows.badField`
- **AND** the error SHALL include the file:line:col position of `badField` in the values file

#### Scenario: Pattern constraint fields are not flagged as disallowed

- **WHEN** values contain `media: { tvshows: { mountPath: "/data/tv", size: "100Gi" } }`
- **AND** `#config.media` uses a pattern constraint `[Name=string]: { mountPath: string, size: string }`
- **THEN** the validator SHALL NOT emit any errors for `values.media.tvshows`
- **AND** the validator SHALL recurse into `tvshows` to validate its children against the pattern's constraint struct

#### Scenario: Type mismatch at nested level is caught with correct path

- **WHEN** values contain `media: { movies: "not-a-struct" }`
- **AND** `#config.media` uses a pattern constraint `[Name=string]: { mountPath: string, size: string }`
- **THEN** the validator SHALL emit a type mismatch error for `values.media.movies`
- **AND** the error SHALL NOT recurse into the errored field

#### Scenario: Optional fields in schema are accepted

- **WHEN** `#config` defines `publishedServerUrl?: string`
- **AND** values contain `publishedServerUrl: "https://example.com"`
- **THEN** the validator SHALL NOT emit any errors for `values.publishedServerUrl`

#### Scenario: Empty values struct passes validation

- **WHEN** values contain no fields (empty struct)
- **THEN** the validator SHALL return no errors

### Requirement: Validation error paths use values-rooted paths

All validation errors produced by the values-against-config validation SHALL use paths rooted at `values` (e.g., `values.media."test-key"`) instead of paths rooted at `#config` (e.g., `#config.media."test-key"`).

For "field not allowed" errors generated by the custom closedness checker, the path SHALL be constructed directly with the `values.` prefix.

For type/constraint errors from CUE unification, the error path SHALL be rewritten by prepending the `values`-rooted field path to the CUE error's relative path.

#### Scenario: Closedness error path is values-rooted

- **WHEN** a "field not allowed" error is emitted for a field at `#config.someField`
- **THEN** the error path SHALL be `values.someField`, not `#config.someField`

#### Scenario: Type mismatch error path is values-rooted

- **WHEN** a type mismatch occurs at `#config.media."test-key"`
- **THEN** the error path in the formatted output SHALL be `values.media."test-key"`

#### Scenario: Deeply nested error path is fully qualified

- **WHEN** a validation error occurs 4 levels deep in the values struct
- **THEN** the error path SHALL include all intermediate field names (e.g., `values.a.b.c.d`)

### Requirement: Every validation error includes source file position

All validation errors produced by the values-against-config validation SHALL include at least one `file:line:col` position pointing to the source location in the user's values file.

For "field not allowed" errors, the position SHALL be determined using `cue.Value.Pos()` on the data field value. For unified values (multiple sources), `cue.Value.Expr()` SHALL be used to decompose the value into its constituent conjuncts and extract per-source positions.

For type/constraint errors from CUE unification, the positions from CUE's native error reporting SHALL be preserved (these already include positions from both the schema and data sides).

#### Scenario: Single values file error has position

- **WHEN** a "field not allowed" error is emitted for a field defined in `val.cue` at line 20, column 2
- **THEN** the error output SHALL include `→ ./val.cue:20:2`

#### Scenario: Multi-file error attributes to correct source

- **WHEN** values are provided via `-f base.cue -f overrides.cue`
- **AND** `overrides.cue` introduces a disallowed field at line 5, column 3
- **THEN** the error output SHALL include `→ ./overrides.cue:5:3`

#### Scenario: Type mismatch shows both schema and data positions

- **WHEN** a type mismatch occurs between a schema constraint in `module.cue:46:24` and a value in `val.cue:18:25`
- **THEN** the error output SHALL include both `→ ./module.cue:46:24` and `→ ./val.cue:18:25`

#### Scenario: Graceful fallback when position unavailable

- **WHEN** a validation error occurs on a value that has no source position info (e.g., computed by CUE)
- **THEN** the error SHALL still be reported with its path and message
- **AND** the position line SHALL be omitted rather than showing an invalid position

### Requirement: Multiple values files are unified before validation

When multiple `--values` / `-f` files are provided, the ReleaseBuilder SHALL unify all values files into a single merged value BEFORE running validation against `#config`.

Values files SHALL NOT be validated individually against `#config`, as individual files may be intentionally incomplete (e.g., base configuration in one file, environment-specific overrides in another).

Source attribution for errors in the merged value SHALL use `cue.Value.Expr()` to decompose unified values back to their originating conjuncts with preserved source positions.

#### Scenario: Split values across files validates correctly

- **WHEN** `base.cue` provides `values: { image: "nginx", port: 80 }`
- **AND** `env.cue` provides `values: { timezone: "UTC", configStorageSize: "10Gi" }`
- **AND** both files together satisfy all `#config` requirements
- **THEN** validation SHALL pass without errors
- **AND** neither file SHALL be rejected for being individually incomplete

#### Scenario: Conflicting values between files uses CUE native error

- **WHEN** `a.cue` provides `values: { port: 8080 }`
- **AND** `b.cue` provides `values: { port: 9090 }`
- **THEN** CUE's native unification error SHALL be returned
- **AND** the error SHALL include positions from both files

## MODIFIED Requirements

### Requirement: mod build --verbose shows per-resource validation lines

The `--verbose` output of `opm mod build` SHALL include per-resource validation lines in the "Generated Resources" section. Each resource SHALL be rendered using `FormatResourceLine` with `"valid"` status, matching the `r:<Kind/namespace/name>  <status>` format used by `mod apply`.

This replaces the current plain-text resource listing in verbose output.

#### Scenario: Verbose output renders resources with FormatResourceLine

- **WHEN** `opm mod build . --verbose` is run on a valid module that generates 3 resources
- **THEN** the "Generated Resources" section SHALL contain 3 lines
- **THEN** each line SHALL use `FormatResourceLine(kind, namespace, name, "valid")` format
- **THEN** the `r:` prefix SHALL be dim, resource path SHALL be cyan, and `"valid"` SHALL be green

#### Scenario: Verbose output aligns with mod apply resource output

- **WHEN** `opm mod build . --verbose` generates a `StatefulSet/default/jellyfin` resource
- **THEN** the verbose output SHALL render: `r:StatefulSet/default/jellyfin          valid`
- **THEN** the format SHALL be visually consistent with `mod apply`'s `r:StatefulSet/default/jellyfin  created`

#### Scenario: Build validation errors show values-rooted paths

- **WHEN** `opm mod build . -f values.cue` fails due to a disallowed field in values
- **THEN** the error details SHALL show paths rooted at `values.` (e.g., `values."extra-field"`)
- **AND** the error details SHALL include file:line:col positions from the values file
