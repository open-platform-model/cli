## Context

Today, `validateValuesAgainstConfig` in `internal/build/errors.go` validates user-provided values against the `#config` definition by iterating top-level fields, wrapping each in a single-field struct, and unifying with `#config`. This was introduced to work around a CUE engine limitation where closedness errors are suppressed when type mismatches exist in the same struct.

The approach has three UX problems:

1. **Wrong paths**: CUE errors report paths rooted at `#config` (e.g., `#config.media."test"`) because the unification merges data into the definition. Users write `values: { ... }` and expect errors to reference `values.X`.

2. **Missing positions on closedness errors**: CUE's internal closedness checker (`typocheck.go`) generates "field not allowed" errors with minimal position info — often just the definition side, not the data side. Users can't tell which file introduced the bad field.

3. **No source file attribution**: When multiple `-f` files are passed, all values are unified together. Errors don't indicate which file contributed the offending field.

The current validation only iterates top-level fields (one level deep). Nested disallowed fields inside allowed structs (e.g., a typo inside `media: { tvshows: { badField: ... } }`) are caught by CUE's unification but still suffer from the path and position problems above.

### CUE SDK Findings

Investigation of the CUE SDK (v0.15.4) revealed:

- **`Value.Allows(sel)`** checks if a field could be added to a struct. Returns `true` for open structs, pattern-constrained fields, and existing fields. Returns `false` for closed structs without a matching field. This gives us programmatic closedness checking with no reliance on CUE's error system.

- **`Value.Expr()`** decomposes a unified value into its constituent conjuncts. After `a.Unify(b)`, calling `result.Expr()` returns `(AndOp, [partA, partB])` where each part retains its original source position. This solves source attribution for unified values.

- **`cue.Str(key).Optional()`** resolves through pattern constraints. Given `media: [Name=string]: { ... }`, `LookupPath(MakePath(Str("tvshows").Optional()))` returns the pattern's constraint value `{mountPath: string, ...}` — allowing recursive descent into pattern-matched fields.

- **`Value.Pos()`** returns position info. For single-source values this works directly. For multi-source (post-unification) values, `Pos()` returns the last conjunct's position; `Expr()` is needed to get per-source positions.

## Goals / Non-Goals

**Goals:**

- Every validation error includes at least one file:line:col position pointing to the user's values file
- Error paths use `values.X` (the user's perspective), never `#config.X`
- Recursive validation to any depth — nested disallowed fields and type mismatches are caught at their exact location
- Pattern constraints (`[Name=string]: { ... }`) are handled correctly — allowed keys are not flagged as disallowed
- Multiple `-f` files are unified first (avoiding false negatives from incomplete individual files), then validated with source attribution back to originating files
- Closedness errors ("field not allowed") are generated by our code with full position info, not by CUE's sparse closedness checker

**Non-Goals:**

- Changing the error output format or styling (colors, arrow prefix, etc.) — `formatCUEDetails` stays as-is
- Changing the `ReleaseValidationError` struct or any public API
- Grouping errors by file in the output — errors remain flat
- Validating values files individually before merging (this causes false negatives)
- Supporting bare values without the `values: { ... }` wrapper in `-f` files
- Handling conflicting values between `-f` files specially — CUE's native unification error passes through

## Decisions

### Decision 1: Custom closedness check via `Value.Allows()` instead of relying on CUE

**Choice**: Implement our own field-existence check using `Value.Allows()` rather than depending on CUE's closedness errors.

**Why**: CUE's internal closedness checker generates errors with minimal position info (often only the definition side). It also has the suppression bug that `validateValuesAgainstConfig` was originally built to work around. By checking `Allows()` ourselves, we control the error message, path, and position completely.

**Alternative considered**: Use `Value.Subsume()` which is designed for "does data satisfy schema?" checks. Rejected because Subsume's error paths are still schema-rooted, and it doesn't necessarily give better position info for closedness violations.

### Decision 2: Unify all value files first, then validate

**Choice**: Merge all `-f` files into a single unified value via `Value.Unify()`, then run validation against `#config` on the merged result.

**Why**: Validating files individually causes false negatives — one file may be intentionally incomplete (e.g., base config in file A, environment overrides in file B). Only the merged result represents the user's intent.

**Source attribution**: After unification, `Value.Expr()` decomposes fields back to their originating conjuncts, each with preserved `Pos()`. For closedness errors, we call `Expr()` on the disallowed field to find which file introduced it. For type errors, CUE's own errors already include positions from both sides.

### Decision 3: Recursive walker with schema resolution at each level

**Choice**: Walk the values struct recursively, resolving the corresponding schema node at each level before descending.

**Why**: The current code only validates top-level fields. Nested errors inside allowed structs get caught by CUE's general validation but with poor paths/positions. Recursive walking means every level gets our improved error handling.

**Schema resolution strategy at each level**:

1. Check `schema.Allows(cue.Str(fieldName))` — if false, emit "field not allowed" and stop
2. Try `schema.LookupPath(MakePath(sel))` for literal fields
3. Fall back to `schema.LookupPath(MakePath(Str(key).Optional()))` for pattern-matched fields
4. Unify `schemaField` with `dataField` and check for type errors
5. If the field is a struct and validation passes, recurse into children

### Decision 4: Thin wrapper type for path-rewritten CUE errors

**Choice**: Implement a `pathRewrittenError` struct that wraps `cueerrors.Error` and overrides `Path()` to return `values.X` paths.

**Why**: CUE's error types don't have a "set path" function. The existing CUE error API is interface-based (`cueerrors.Error`), so wrapping with an override is the idiomatic approach. This avoids string manipulation on error messages and works cleanly with `formatCUEDetails` which calls `e.Path()` directly.

**Interface**: Implements `cueerrors.Error`, delegates all methods to the inner error except `Path()` which returns the rewritten path.

### Decision 5: Stop recursion on error

**Choice**: When a field fails validation (either closedness or type check), don't recurse into its children.

**Why**: If `values.media."bad-key"` is a string where a struct is expected, recursing into a string value makes no sense. If a field isn't allowed at all, checking its children is meaningless. This also prevents cascading duplicate errors.

## Risks / Trade-offs

**[Risk: `Value.Allows()` behavior mismatch with CUE closedness]** We're reimplementing part of CUE's closedness semantics. If CUE's `Allows()` disagrees with its internal closedness checker in edge cases, we could produce different results. → Mitigation: `Allows()` delegates to the same `Accept()` method used by CUE's evaluator. It's the public API for exactly this question. Comprehensive tests covering closed structs, definitions, pattern constraints, and optional fields will catch divergences.

**[Risk: Performance on deeply nested modules]** Recursive walking with per-field unification is more expensive than a single `Validate()` call. → Mitigation: Real-world modules have 2-4 levels of config nesting. The validation is I/O-bound (file loading) not CPU-bound (field checking). No measurable impact expected.

**[Risk: `Value.Expr()` returns unexpected structure]** If CUE's internal representation changes, `Expr()` might return different `Op` types or conjunct structures. → Mitigation: `Expr()` is a public API with documented behavior. We fall back gracefully to `Value.Pos()` when `Expr()` doesn't return `AndOp`. Source attribution is best-effort — the error is still reported even without a position.

**[Trade-off: Duplicating CUE's validation work]** We run our own closedness check AND CUE's type unification. This means some validation work is done twice. → Accepted: The clarity of error messages is worth the negligible performance cost. The custom closedness check runs fast (just `Allows()` calls), and the type check is only run on fields that pass closedness.
